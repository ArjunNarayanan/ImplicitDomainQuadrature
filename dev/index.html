<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ImplicitDomainQuadrature.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ImplicitDomainQuadrature.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ImplicitDomainQuadrature.jl-1"><a class="docs-heading-anchor" href="#ImplicitDomainQuadrature.jl-1">ImplicitDomainQuadrature.jl</a><a class="docs-heading-anchor-permalink" href="#ImplicitDomainQuadrature.jl-1" title="Permalink"></a></h1><ul><li><a href="#ImplicitDomainQuadrature.AbstractBasis"><code>ImplicitDomainQuadrature.AbstractBasis</code></a></li><li><a href="#ImplicitDomainQuadrature.AbstractBasis1D"><code>ImplicitDomainQuadrature.AbstractBasis1D</code></a></li><li><a href="#ImplicitDomainQuadrature.InterpolatingPolynomial-Union{Tuple{NFuncs}, Tuple{Type{#s15} where #s15&lt;:Number,Int64,ImplicitDomainQuadrature.AbstractBasis{NFuncs}}} where NFuncs"><code>ImplicitDomainQuadrature.InterpolatingPolynomial</code></a></li><li><a href="#ImplicitDomainQuadrature.InterpolatingPolynomial-Tuple"><code>ImplicitDomainQuadrature.InterpolatingPolynomial</code></a></li><li><a href="#ImplicitDomainQuadrature.InterpolatingPolynomial"><code>ImplicitDomainQuadrature.InterpolatingPolynomial</code></a></li><li><a href="#ImplicitDomainQuadrature.LagrangePolynomialBasis"><code>ImplicitDomainQuadrature.LagrangePolynomialBasis</code></a></li><li><a href="#ImplicitDomainQuadrature.LagrangePolynomialBasis-Union{Tuple{T}, Tuple{Int64,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.LagrangePolynomialBasis</code></a></li><li><a href="#ImplicitDomainQuadrature.QuadratureRule"><code>ImplicitDomainQuadrature.QuadratureRule</code></a></li><li><a href="#ImplicitDomainQuadrature.ReferenceQuadratureRule"><code>ImplicitDomainQuadrature.ReferenceQuadratureRule</code></a></li><li><a href="#ImplicitDomainQuadrature.SignSearch"><code>ImplicitDomainQuadrature.SignSearch</code></a></li><li><a href="#ImplicitDomainQuadrature.TensorProductBasis-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.TensorProductBasis</code></a></li><li><a href="#ImplicitDomainQuadrature.TensorProductBasis"><code>ImplicitDomainQuadrature.TensorProductBasis</code></a></li><li><a href="#Base.:==-Union{Tuple{NF}, Tuple{T}, Tuple{D}, Tuple{TensorProductBasis{D,T,NF},TensorProductBasis{D,T,NF}}} where NF where T where D"><code>Base.:==</code></a></li><li><a href="#Base.:==-Union{Tuple{NF}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis{NF},ImplicitDomainQuadrature.LagrangePolynomialBasis{NF}}} where NF"><code>Base.:==</code></a></li><li><a href="#Base.getindex-Union{Tuple{N}, Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T} where T,Int64}} where N"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Union{Tuple{D}, Tuple{QuadratureRule{D,T} where T,Int64}} where D"><code>Base.getindex</code></a></li><li><a href="#Base.isequal-Union{Tuple{NF}, Tuple{T}, Tuple{D}, Tuple{TensorProductBasis{D,T,NF},TensorProductBasis{D,T,NF}}} where NF where T where D"><code>Base.isequal</code></a></li><li><a href="#Base.isequal-Union{Tuple{NF}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis{NF},ImplicitDomainQuadrature.LagrangePolynomialBasis{NF}}} where NF"><code>Base.isequal</code></a></li><li><a href="#Base.iterate-Union{Tuple{QuadratureRule{D,T} where T}, Tuple{D}, Tuple{QuadratureRule{D,T} where T,Any}} where D"><code>Base.iterate</code></a></li><li><a href="#Base.iterate-Union{Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T} where T}, Tuple{N}, Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T} where T,Any}} where N"><code>Base.iterate</code></a></li><li><a href="#Base.muladd-Union{Tuple{T}, Tuple{TaylorModels.TaylorModelN,T,T}} where T&lt;:Number"><code>Base.muladd</code></a></li><li><a href="#Base.sign-Union{Tuple{B}, Tuple{S}, Tuple{N}, Tuple{D}, Tuple{T}, Tuple{NF}, Tuple{InterpolatingPolynomial{1,NF,B,T},IntervalArithmetic.IntervalBox}} where B&lt;:TensorProductBasis{D,S,N} where S&lt;:ImplicitDomainQuadrature.LagrangePolynomialBasis where N where D where T where NF"><code>Base.sign</code></a></li><li><a href="#Base.sign-Union{Tuple{T}, Tuple{Any,IntervalArithmetic.IntervalBox,Int64,T}} where T&lt;:Real"><code>Base.sign</code></a></li><li><a href="#Base.sign-Tuple{Int64,Int64,Bool,Int64}"><code>Base.sign</code></a></li><li><a href="#BranchAndPrune.bisect-Tuple{ImplicitDomainQuadrature.SignSearch,IntervalArithmetic.IntervalBox}"><code>BranchAndPrune.bisect</code></a></li><li><a href="#BranchAndPrune.process-Tuple{ImplicitDomainQuadrature.SignSearch,IntervalArithmetic.IntervalBox}"><code>BranchAndPrune.process</code></a></li><li><a href="#ImplicitDomainQuadrature.coefficient_number_type-Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis}"><code>ImplicitDomainQuadrature.coefficient_number_type</code></a></li><li><a href="#ImplicitDomainQuadrature.derivative-Union{Tuple{T}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis,T}} where T&lt;:Number"><code>ImplicitDomainQuadrature.derivative</code></a></li><li><a href="#ImplicitDomainQuadrature.extend-Tuple{Number,Int64,Number}"><code>ImplicitDomainQuadrature.extend</code></a></li><li><a href="#ImplicitDomainQuadrature.gradient-Union{Tuple{N}, Tuple{TensorProductBasis{N,T,NF} where NF where T,Int64,AbstractArray{T,1} where T}} where N"><code>ImplicitDomainQuadrature.gradient</code></a></li><li><a href="#ImplicitDomainQuadrature.gradient-Union{Tuple{T}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis,T}} where T&lt;:Number"><code>ImplicitDomainQuadrature.gradient</code></a></li><li><a href="#ImplicitDomainQuadrature.gradient-Tuple{InterpolatingPolynomial{1,NFuncs,B,T} where T where B&lt;:ImplicitDomainQuadrature.AbstractBasis where NFuncs,Number}"><code>ImplicitDomainQuadrature.gradient</code></a></li><li><a href="#ImplicitDomainQuadrature.interpolation_points-Union{Tuple{NF}, Tuple{Int64,ImplicitDomainQuadrature.AbstractBasis1D{NF}}} where NF"><code>ImplicitDomainQuadrature.interpolation_points</code></a></li><li><a href="#ImplicitDomainQuadrature.isSuitable-Tuple{Int64,InterpolatingPolynomial,IntervalArithmetic.IntervalBox}"><code>ImplicitDomainQuadrature.isSuitable</code></a></li><li><a href="#ImplicitDomainQuadrature.lagrange_polynomial-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1},Int64}} where T"><code>ImplicitDomainQuadrature.lagrange_polynomial</code></a></li><li><a href="#ImplicitDomainQuadrature.lagrange_polynomials-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1}}} where T"><code>ImplicitDomainQuadrature.lagrange_polynomials</code></a></li><li><a href="#ImplicitDomainQuadrature.min_diam-Tuple{IntervalArithmetic.IntervalBox}"><code>ImplicitDomainQuadrature.min_diam</code></a></li><li><a href="#ImplicitDomainQuadrature.normalization-Union{Tuple{T}, Tuple{AbstractArray{T,1},Int64}} where T"><code>ImplicitDomainQuadrature.normalization</code></a></li><li><a href="#ImplicitDomainQuadrature.polynomial_from_roots-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1},Int64}} where T"><code>ImplicitDomainQuadrature.polynomial_from_roots</code></a></li><li><a href="#ImplicitDomainQuadrature.quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Array{T,1} where T,Array{Int64,1},T,T,ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T}}} where T where N"><code>ImplicitDomainQuadrature.quadrature</code></a></li><li><a href="#ImplicitDomainQuadrature.quadrature_transformers-Tuple{Any,Any}"><code>ImplicitDomainQuadrature.quadrature_transformers</code></a></li><li><a href="#ImplicitDomainQuadrature.roots_and_ends-Union{Tuple{T}, Tuple{Array{T,1} where T,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.roots_and_ends</code></a></li><li><a href="#ImplicitDomainQuadrature.run_search-NTuple{4,Any}"><code>ImplicitDomainQuadrature.run_search</code></a></li><li><a href="#ImplicitDomainQuadrature.signConditionsSatisfied-Tuple{Any,Any,Any}"><code>ImplicitDomainQuadrature.signConditionsSatisfied</code></a></li><li><a href="#ImplicitDomainQuadrature.surface_quadrature-Union{Tuple{T}, Tuple{InterpolatingPolynomial,Int64,T,T,AbstractArray{T,1},T}} where T"><code>ImplicitDomainQuadrature.surface_quadrature</code></a></li><li><a href="#ImplicitDomainQuadrature.tensorProduct-Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule,IntervalArithmetic.IntervalBox{2,T} where T}"><code>ImplicitDomainQuadrature.tensorProduct</code></a></li><li><a href="#ImplicitDomainQuadrature.tensorProductPoints-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>ImplicitDomainQuadrature.tensorProductPoints</code></a></li><li><a href="#ImplicitDomainQuadrature.transform-Union{Tuple{T}, Tuple{N}, Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T},T,T}} where T where N"><code>ImplicitDomainQuadrature.transform</code></a></li><li><a href="#ImplicitDomainQuadrature.unique_root_intervals-Union{Tuple{T}, Tuple{Any,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.unique_root_intervals</code></a></li><li><a href="#ImplicitDomainQuadrature.unique_roots-Union{Tuple{T}, Tuple{Any,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.unique_roots</code></a></li><li><a href="#ImplicitDomainQuadrature.update!-Union{Tuple{T}, Tuple{D}, Tuple{QuadratureRule{D,T},AbstractArray{T,2},AbstractArray{T,1}}} where T where D"><code>ImplicitDomainQuadrature.update!</code></a></li><li><a href="#ImplicitDomainQuadrature.update!-Tuple{InterpolatingPolynomial,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>ImplicitDomainQuadrature.update!</code></a></li><li><a href="#ImplicitDomainQuadrature.value_and_derivative-Union{Tuple{T}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis,T}} where T&lt;:Number"><code>ImplicitDomainQuadrature.value_and_derivative</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.InterpolatingPolynomial" href="#ImplicitDomainQuadrature.InterpolatingPolynomial"><code>ImplicitDomainQuadrature.InterpolatingPolynomial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterpolatingPolynomial{N,NFuncs,B&lt;:AbstractBasis,T}</code></pre><p>interpolate a VECTOR of <code>N</code> with a basis <code>B</code> composed of <code>NFuncs</code> functions</p><p><strong>Fields</strong></p><pre><code class="language-none">- `coeffs::SMatrix{N,NFuncs,T}`
- `basis::B`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/interpolation.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.InterpolatingPolynomial-Tuple" href="#ImplicitDomainQuadrature.InterpolatingPolynomial-Tuple"><code>ImplicitDomainQuadrature.InterpolatingPolynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(P::InterpolatingPolynomial{1})(x...)</code></pre><p>evaluate <code>P</code> at <code>x</code>, the result is a scalar     (P::InterpolatingPolynomial)(x...) evaluate <code>P</code> at <code>x</code>     (P::InterpolatingPolynomial)(x::AbstractVector) evaluate <code>P</code> at the point vector <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/interpolation.jl#LL65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.InterpolatingPolynomial-Union{Tuple{NFuncs}, Tuple{Type{#s15} where #s15&lt;:Number,Int64,ImplicitDomainQuadrature.AbstractBasis{NFuncs}}} where NFuncs" href="#ImplicitDomainQuadrature.InterpolatingPolynomial-Union{Tuple{NFuncs}, Tuple{Type{#s15} where #s15&lt;:Number,Int64,ImplicitDomainQuadrature.AbstractBasis{NFuncs}}} where NFuncs"><code>ImplicitDomainQuadrature.InterpolatingPolynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InterpolatingPolynomial(T::Type{&lt;:Number}, N::Int,
    basis::AbstractBasis{NFuncs}) where {NFuncs}</code></pre><p>initialize an <code>InterpolatingPolynomial{N,NFuncs,T}</code> object with coefficients <code>zeros(T,N,NFuncs)</code>     InterpolatingPolynomial(N::Int, basis::AbstractBasis) initialize an <code>InterpolatingPolynomial</code> object with <code>Float64</code> coefficients.     InterpolatingPolynomial(N::Int, dim::Int, order::Int, start::T, stop::T) where {T&lt;:Real} initialize a <code>dim</code> dimensional basis of order <code>order</code> and pass this to the <code>InterpolatingPolynomial</code> constructor.     InterpolatingPolynomial(N::Int, dim::Int, order::Int; start = -1.0, stop = 1.0) initialize a <code>dim</code> dimensional basis of order <code>order</code> and pass this to the <code>InterpolatingPolynomial</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/interpolation.jl#LL22-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.QuadratureRule" href="#ImplicitDomainQuadrature.QuadratureRule"><code>ImplicitDomainQuadrature.QuadratureRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuadratureRule{D,T}</code></pre><p>a quadrature rule in <code>D</code> spatial dimensions. This is a mutable type; points and weights can be added via the <code>update!</code> method.</p><p><strong>Inner Constructor:</strong></p><pre><code class="language-none">QuadratureRule(points::Matrix{T}, weights::Vector{T}) where {T&lt;:Real}</code></pre><p><strong>Outer Constructors:</strong></p><pre><code class="language-none">QuadratureRule(T::Type{&lt;:Real}, dim::Int)</code></pre><p>initializes <code>(dim,0)</code> matrix of points and <code>(0)</code> vector of weights. Both are of type <code>T</code>     QuadratureRule(dim::Int) initializes <code>(dim,0)</code> matrix of points and <code>(0)</code> vector of weights of type <code>Float64</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL112-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.TensorProductBasis" href="#ImplicitDomainQuadrature.TensorProductBasis"><code>ImplicitDomainQuadrature.TensorProductBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TensorProductBasis{N,NFuncs,T&lt;:AbstractBasis1D} &lt;: AbstractBasis{NFuncs}</code></pre><p>construct an <code>N</code> dimensional polynomial basis by tensor product of <code>T</code> with a total of <code>NFuncs</code> functions. Note that <code>NFuncs</code> can be inferred from <code>T{nfuncs}</code> as <code>NFuncs = nfuncs^N</code>.</p><p><strong>Fields</strong></p><pre><code class="language-none">- `basis::T` the underlying 1D basis
- `points::SMatrix{N,NFuncs}` a matrix of point vectors</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL109-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.TensorProductBasis-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T&lt;:Real" href="#ImplicitDomainQuadrature.TensorProductBasis-Union{Tuple{T}, Tuple{Int64,Int64,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.TensorProductBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TensorProductBasis(dim::Int, order::Int; start = -1.0, stop = 1.0)</code></pre><p>construct a <code>dim</code> dimensional polynomial basis with variable <code>x</code> using a tensor product of <code>order</code> order <code>LagrangePolynomialBasis</code>. The polynomials are equispaced from <code>start</code> to <code>stop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL133-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Union{Tuple{NF}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis{NF},ImplicitDomainQuadrature.LagrangePolynomialBasis{NF}}} where NF" href="#Base.:==-Union{Tuple{NF}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis{NF},ImplicitDomainQuadrature.LagrangePolynomialBasis{NF}}} where NF"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(b1::LagrangePolynomialBasis{NF},b2::LagrangePolynomialBasis{NF}) where {NF}</code></pre><p>returns true if <code>b1</code> and <code>b2</code> have the same <code>funcs</code> and <code>points</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL99-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Union{Tuple{NF}, Tuple{T}, Tuple{D}, Tuple{TensorProductBasis{D,T,NF},TensorProductBasis{D,T,NF}}} where NF where T where D" href="#Base.:==-Union{Tuple{NF}, Tuple{T}, Tuple{D}, Tuple{TensorProductBasis{D,T,NF},TensorProductBasis{D,T,NF}}} where NF where T where D"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(tp1::TensorProductBasis{D,T,NF}, tp2::TensorProductBasis{D,T,NF}) where {D,T,NF}</code></pre><p>returns <code>true</code> if <code>tp1</code> and <code>tp2</code> have identical <code>basis</code> and <code>points</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL169-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Union{Tuple{NF}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis{NF},ImplicitDomainQuadrature.LagrangePolynomialBasis{NF}}} where NF" href="#Base.isequal-Union{Tuple{NF}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis{NF},ImplicitDomainQuadrature.LagrangePolynomialBasis{NF}}} where NF"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isequal(b1::LagrangePolynomialBasis{NF},b2::LagrangePolynomialBasis{NF}) where {NF}</code></pre><p>returns true if <code>b1</code> and <code>b2</code> have the same <code>funcs</code> and <code>points</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL88-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Union{Tuple{NF}, Tuple{T}, Tuple{D}, Tuple{TensorProductBasis{D,T,NF},TensorProductBasis{D,T,NF}}} where NF where T where D" href="#Base.isequal-Union{Tuple{NF}, Tuple{T}, Tuple{D}, Tuple{TensorProductBasis{D,T,NF},TensorProductBasis{D,T,NF}}} where NF where T where D"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isequal(tp1::TensorProductBasis{D,T,NF}, tp2::TensorProductBasis{D,T,NF}) where {D,T,NF}</code></pre><p>returns <code>true</code> if <code>tp1</code> and <code>tp2</code> have identical <code>basis</code> and <code>points</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL161-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Tuple{Int64,Int64,Bool,Int64}" href="#Base.sign-Tuple{Int64,Int64,Bool,Int64}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.sign(m::Int,s::Int,S::Bool,sigma::Int)</code></pre><p>See sec. 3.2.4 of Robert Saye&#39;s 2015 SIAM paper</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/dimension_reduction.jl#LL256-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Union{Tuple{B}, Tuple{S}, Tuple{N}, Tuple{D}, Tuple{T}, Tuple{NF}, Tuple{InterpolatingPolynomial{1,NF,B,T},IntervalArithmetic.IntervalBox}} where B&lt;:TensorProductBasis{D,S,N} where S&lt;:ImplicitDomainQuadrature.LagrangePolynomialBasis where N where D where T where NF" href="#Base.sign-Union{Tuple{B}, Tuple{S}, Tuple{N}, Tuple{D}, Tuple{T}, Tuple{NF}, Tuple{InterpolatingPolynomial{1,NF,B,T},IntervalArithmetic.IntervalBox}} where B&lt;:TensorProductBasis{D,S,N} where S&lt;:ImplicitDomainQuadrature.LagrangePolynomialBasis where N where D where T where NF"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.sign(P::InterpolatingPolynomial{1}, int::IntervalBox; algorithm = :TaylorModels, tol = 1e-3, order = 5)</code></pre><p>special function for an interpolating polynomial type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/bounds.jl#LL155-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Union{Tuple{T}, Tuple{Any,IntervalArithmetic.IntervalBox,Int64,T}} where T&lt;:Real" href="#Base.sign-Union{Tuple{T}, Tuple{Any,IntervalArithmetic.IntervalBox,Int64,T}} where T&lt;:Real"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sign(f, int::Interval)</code></pre><p>return</p><ul><li><code>+1</code> if <code>f</code> is uniformly positive on <code>int</code></li><li><code>-1</code> if <code>f</code> is uniformly negative on <code>int</code></li><li><code>0</code> if <code>f</code> has at least one zero crossing in <code>int</code> (f assumed continuous)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/bounds.jl#LL118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.gradient-Tuple{InterpolatingPolynomial{1,NFuncs,B,T} where T where B&lt;:ImplicitDomainQuadrature.AbstractBasis where NFuncs,Number}" href="#ImplicitDomainQuadrature.gradient-Tuple{InterpolatingPolynomial{1,NFuncs,B,T} where T where B&lt;:ImplicitDomainQuadrature.AbstractBasis where NFuncs,Number}"><code>ImplicitDomainQuadrature.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradient(P::InterpolatingPolynomial)(x)</code></pre><p>return the gradient of <code>P</code> evaluated at <code>x</code>.     gradient(P::InterpolatingPolynomial, dir::Int, x...) return the gradient of <code>P</code> along direction <code>dir</code> evaluated at <code>x</code>.     gradient(P::InterpolatingPolynomial, x::AbstractVector) evaluate the gradient of <code>P</code> at the point vector <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/interpolation.jl#LL81-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.gradient-Union{Tuple{N}, Tuple{TensorProductBasis{N,T,NF} where NF where T,Int64,AbstractArray{T,1} where T}} where N" href="#ImplicitDomainQuadrature.gradient-Union{Tuple{N}, Tuple{TensorProductBasis{N,T,NF} where NF where T,Int64,AbstractArray{T,1} where T}} where N"><code>ImplicitDomainQuadrature.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradient(B::TensorProductBasis{N}, dir::Int, x::AbstractVector) where {N}</code></pre><p>evaluate the gradient of <code>B</code> along direction <code>dir</code> at the point vector <code>x</code>     gradient(B::TensorProductBasis{dim}, x::AbstractVector) where {dim} return an <code>(N,dim)</code> matrix such that the <code>I</code>th row is the gradient of basis <code>I</code>. Here <code>N</code> is the total number of basis functions.     gradient(B::TensorProductBasis{3}, dir::Int, x::Number, y::Number, z::Number) evaluate the gradient of <code>B</code> at <code>(x,y,z)</code> along direction <code>dir</code>.     gradient(B::TensorProductBasis{3}, x::Number, y::Number, z::Number) returns an <code>(N,3)</code> matrix, where row <code>I</code> is the (2D) gradient vector of the <code>I</code>th basis function. Here <code>N</code> is the total number of basis functions.     gradient(B::TensorProductBasis{2}, x::Number, y::Number) returns an <code>(N,2)</code> matrix, where row <code>I</code> is the (2D) gradient vector of the <code>I</code>th basis function. Here <code>N</code> is the total number of basis functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL299-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.gradient-Union{Tuple{T}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis,T}} where T&lt;:Number" href="#ImplicitDomainQuadrature.gradient-Union{Tuple{T}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis,T}} where T&lt;:Number"><code>ImplicitDomainQuadrature.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradient(B::LagrangePolynomialBasis, x::Number)</code></pre><p>alias for <code>derivative(B, x)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL193-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.interpolation_points-Union{Tuple{NF}, Tuple{Int64,ImplicitDomainQuadrature.AbstractBasis1D{NF}}} where NF" href="#ImplicitDomainQuadrature.interpolation_points-Union{Tuple{NF}, Tuple{Int64,ImplicitDomainQuadrature.AbstractBasis1D{NF}}} where NF"><code>ImplicitDomainQuadrature.interpolation_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolation_points(B::TensorProductBasis{N,NFuncs,T}) where {NFuncs,T}</code></pre><p>return the interpolation points of the tensor product basis</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL342-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Array{T,1} where T,Array{Int64,1},T,T,ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T}}} where T where N" href="#ImplicitDomainQuadrature.quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Array{T,1} where T,Array{Int64,1},T,T,ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T}}} where T where N"><code>ImplicitDomainQuadrature.quadrature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quadrature(F::Vector, sign_conditions::Vector{Int}, lo::T, hi::T, quad1d::ReferenceQuadratureRule{N,T}) where {N,T}</code></pre><p>return a 1D quadrature rule that can be used to integrate in the domain where each <code>f in F</code> has sign specified in <code>sign_conditions</code> in the interval <code>[lo,hi]</code>     quadrature(F::Vector, sign<em>conditions::Vector{Int}, int::Interval{T}, quad1d::ReferenceQuadratureRule{N,T}) where {N,T} conveniance function for when the interval over which the quadrature rule is required is specified by an <code>Interval</code> type     quadrature(F::Vector, sign</em>conditions::Vector{Int}, height<em>dir::Int, lo::T, hi::T, x0::AbstractVector{T}, w0::T, quad1d::ReferenceQuadratureRule{N,T}) where {N,T} return a tuple <code>points,weights</code> representing quadrature points and weights obtained by transforming <code>quad1d</code> into an interval bounded by <code>x0</code> and the zero level set of <code>F</code> by extending along `height</em>dir`     quadrature(F::Vector, sign<em>conditions::Vector{Int}, height</em>dir::Int, lo::T, hi::T, x0::AbstractMatrix, w0::AbstractVector, quad1d::ReferenceQuadratureRule{N,T}) where {N,T}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/dimension_reduction.jl#LL102-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.update!-Tuple{InterpolatingPolynomial,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}" href="#ImplicitDomainQuadrature.update!-Tuple{InterpolatingPolynomial,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>ImplicitDomainQuadrature.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(P::InterpolatingPolynomial, coeffs::AbstractMatrix)</code></pre><p>update <code>P.coeffs = coeffs</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/interpolation.jl#LL57-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.update!-Union{Tuple{T}, Tuple{D}, Tuple{QuadratureRule{D,T},AbstractArray{T,2},AbstractArray{T,1}}} where T where D" href="#ImplicitDomainQuadrature.update!-Union{Tuple{T}, Tuple{D}, Tuple{QuadratureRule{D,T},AbstractArray{T,2},AbstractArray{T,1}}} where T where D"><code>ImplicitDomainQuadrature.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(quad::QuadratureRule{D,T}, points::AbstractMatrix{T}, weights::AbstractVector{T}) where {D,T}</code></pre><p>concatenates <code>points</code> and <code>weights</code> into <code>quad.points</code> and <code>quad.weights</code> and increments <code>quad.N</code> appropriately.     update!(quad::QuadratureRule{D,T}, point::AbstractVector{T}, weight::T) where {D,T} adds a single <code>point,weight</code> pair to <code>quad</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL173-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.AbstractBasis" href="#ImplicitDomainQuadrature.AbstractBasis"><code>ImplicitDomainQuadrature.AbstractBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractBasis{N}</code></pre><p>abstract supertype for a function basis with <code>N</code> functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.AbstractBasis1D" href="#ImplicitDomainQuadrature.AbstractBasis1D"><code>ImplicitDomainQuadrature.AbstractBasis1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractBasis1D{N}</code></pre><p>abstract supertype for a 1D function basis with <code>N</code> functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.LagrangePolynomialBasis" href="#ImplicitDomainQuadrature.LagrangePolynomialBasis"><code>ImplicitDomainQuadrature.LagrangePolynomialBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LagrangePolynomialBasis{N} &lt;: AbstractBasis1D{N}</code></pre><p>A basis of <code>N</code> Lagrange polynomials. The polynomial order is <code>N - 1</code>.</p><p><strong>Fields</strong></p><pre><code class="language-none">- `funcs::PolynomialSystem{N,1}` - a system of static polynomials
- `points::StaticVector{N}` - a static vector of support points</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.LagrangePolynomialBasis-Union{Tuple{T}, Tuple{Int64,T,T}} where T&lt;:Real" href="#ImplicitDomainQuadrature.LagrangePolynomialBasis-Union{Tuple{T}, Tuple{Int64,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.LagrangePolynomialBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LagrangePolynomialBasis(order::Int, start::T, stop::T) where {T&lt;:Real}</code></pre><p>construct a polynomial basis with variable <code>x</code> of order <code>order</code> with equally spaced points between <code>start</code> and <code>stop</code>.     LagrangePolynomialBasis(order::Int) construct a polynomial basis with variable <code>x</code> of order <code>order</code> with equally spaced points of type <code>T</code> between <code>-1.0</code> and <code>1.0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL67-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.ReferenceQuadratureRule" href="#ImplicitDomainQuadrature.ReferenceQuadratureRule"><code>ImplicitDomainQuadrature.ReferenceQuadratureRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReferenceQuadratureRule{N,T}</code></pre><p>a one-dimensional quadrature rule defined on the reference domain <code>[-1,1]</code>.</p><p><strong>Inner Constructors:</strong></p><pre><code class="language-none">ReferenceQuadratureRule(points::SMatrix{1,N,T}, weights::SVector{N,T}) where {T&lt;:Real}</code></pre><p><strong>Outer Constructors:</strong></p><pre><code class="language-none">ReferenceQuadratureRule(points::AbstractMatrix, weights::AbstractVector)
ReferenceQuadratureRule(points::AbstractVector, weights::AbstractVector)
ReferenceQuadratureRule(N::Int)</code></pre><p>return an <code>N</code> point gauss legendre quadrature rule on <code>[-1,1]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.SignSearch" href="#ImplicitDomainQuadrature.SignSearch"><code>ImplicitDomainQuadrature.SignSearch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SignSearch{N,T} &lt;: AbstractBreadthFirstSearch{IntervalBox{N,T}}</code></pre><p>a <code>BranchAndPrune</code> search type that is used to determine the sign of a function over a given interval</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/bounds.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{D}, Tuple{QuadratureRule{D,T} where T,Int64}} where D" href="#Base.getindex-Union{Tuple{D}, Tuple{QuadratureRule{D,T} where T,Int64}} where D"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(quad::QuadratureRule{D}, i::Int) where {D}</code></pre><p>return <code>(p,w)</code> where <code>p</code> is an appropriate view into the <code>i</code>th quadrature point, and <code>w</code> is the <code>i</code>th quadrature weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{N}, Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T} where T,Int64}} where N" href="#Base.getindex-Union{Tuple{N}, Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T} where T,Int64}} where N"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(quad::ReferenceQuadratureRule{N}, i::Int) where {N}</code></pre><p>return the <code>i</code>th point weight pair <code>p,w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL69-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Union{Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T} where T}, Tuple{N}, Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T} where T,Any}} where N" href="#Base.iterate-Union{Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T} where T}, Tuple{N}, Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T} where T,Any}} where N"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.iterate(quad::ReferenceQuadratureRule{N}, state=1)</code></pre><p>return each point, weight pair as a tuple <code>(p,w)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL57-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Union{Tuple{QuadratureRule{D,T} where T}, Tuple{D}, Tuple{QuadratureRule{D,T} where T,Any}} where D" href="#Base.iterate-Union{Tuple{QuadratureRule{D,T} where T}, Tuple{D}, Tuple{QuadratureRule{D,T} where T,Any}} where D"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.iterate(quad::QuadratureRule{D}, state=1) where {D}</code></pre><p>return each point, weight pair as a tuple <code>(p,w)</code> where <code>p</code> is an appropriate view into the point matrix <code>quad.points</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.muladd-Union{Tuple{T}, Tuple{TaylorModels.TaylorModelN,T,T}} where T&lt;:Number" href="#Base.muladd-Union{Tuple{T}, Tuple{TaylorModels.TaylorModelN,T,T}} where T&lt;:Number"><code>Base.muladd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.muladd(tm::TaylorModelN, a::Number, b::Number)</code></pre><p>overloading <code>muladd</code> to avoid an error</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/bounds.jl#LL36-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchAndPrune.bisect-Tuple{ImplicitDomainQuadrature.SignSearch,IntervalArithmetic.IntervalBox}" href="#BranchAndPrune.bisect-Tuple{ImplicitDomainQuadrature.SignSearch,IntervalArithmetic.IntervalBox}"><code>BranchAndPrune.bisect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BranchAndPrune.bisect(::SignSearch, interval::IntervalBox)</code></pre><p>split the given <code>interval</code> along its largest dimension</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/bounds.jl#LL95-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BranchAndPrune.process-Tuple{ImplicitDomainQuadrature.SignSearch,IntervalArithmetic.IntervalBox}" href="#BranchAndPrune.process-Tuple{ImplicitDomainQuadrature.SignSearch,IntervalArithmetic.IntervalBox}"><code>BranchAndPrune.process</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BranchAndPrune.process(search::SignSearch, interval::IntervalBox)</code></pre><p>process the given <code>interval</code> to determine the sign of <code>search.f</code> in this interval</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/bounds.jl#LL71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.coefficient_number_type-Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis}" href="#ImplicitDomainQuadrature.coefficient_number_type-Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis}"><code>ImplicitDomainQuadrature.coefficient_number_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coefficient_number_type(B::LagrangePolynomialBasis)
coefficient_number_type(B::TensorProductBasis)</code></pre><p>return the type of the coefficient, i.e. <code>Float64, Float32</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.derivative-Union{Tuple{T}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis,T}} where T&lt;:Number" href="#ImplicitDomainQuadrature.derivative-Union{Tuple{T}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis,T}} where T&lt;:Number"><code>ImplicitDomainQuadrature.derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative(B::LagrangePolynomialBasis, x::Number)</code></pre><p>evaluate the derivative of basis <code>B</code> at the point <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL185-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.extend-Tuple{Number,Int64,Number}" href="#ImplicitDomainQuadrature.extend-Tuple{Number,Int64,Number}"><code>ImplicitDomainQuadrature.extend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extend(x0::Number, k::Int, x::Number)</code></pre><p>extend <code>x0</code> into 2D space by inserting <code>x</code> in direction <code>k</code>     extend(x0::AbstractVector, k::Int, x::Number) extend the point vector <code>x0</code> into <code>d+1</code> dimensional space by using <code>x</code> as the <code>k</code>th coordinate value in the new point vector     extend(x0::AbstractVector, k::Int, x::AbstractMatrix) extend the point vector <code>x0</code> along direction <code>k</code> treating <code>x</code> as the new coordinate values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/dimension_reduction.jl#LL46-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.isSuitable-Tuple{Int64,InterpolatingPolynomial,IntervalArithmetic.IntervalBox}" href="#ImplicitDomainQuadrature.isSuitable-Tuple{Int64,InterpolatingPolynomial,IntervalArithmetic.IntervalBox}"><code>ImplicitDomainQuadrature.isSuitable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isSuitable(height_dir::Int, F::AbstractVector, box::IntervalBox)</code></pre><p>checks if the given <code>height_dir</code> is a suitable height direction for each <code>f</code> in <code>F</code> in the domain specified by <code>box</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/dimension_reduction.jl#LL242-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.lagrange_polynomial-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1},Int64}} where T" href="#ImplicitDomainQuadrature.lagrange_polynomial-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1},Int64}} where T"><code>ImplicitDomainQuadrature.lagrange_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lagrange_polynomial(x::DP.PolyVar,roots::AbstractVector{T},index::Int) where {T}</code></pre><p>return the <code>index</code>th lagrange polynomial from the vector of <code>roots</code> with variable <code>x</code>.</p><p>The polynomial is normalized such that it evaluates to <code>1.0</code> on <code>roots[index]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import DynamicPolynomials.@polyvar
julia&gt; @polyvar x
(x,)
julia&gt; ImplicitDomainQuadrature.lagrange_polynomial(x,[-1,0,1],2)
-x² + 1.0</code></pre><p>See also: <a href="#ImplicitDomainQuadrature.lagrange_polynomials-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1}}} where T"><code>lagrange_polynomials</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/lagrange_polynomials.jl#LL60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.lagrange_polynomials-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1}}} where T" href="#ImplicitDomainQuadrature.lagrange_polynomials-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1}}} where T"><code>ImplicitDomainQuadrature.lagrange_polynomials</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lagrange_polynomials(x::DP.PolyVar,roots::AbstractVector{T}) where {T}</code></pre><p>return a vector of lagrange polynomial bases constructed from the given <code>roots</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import DynamicPolynomials.@polyvar
julia&gt; @polyvar x
(x,)
julia&gt; ImplicitDomainQuadrature.lagrange_polynomials(x, [-1,0,1])
3-element Array{DynamicPolynomials.Polynomial{true,Float64},1}:
 0.5x² - 0.5x
 -x² + 1.0
 0.5x² + 0.5x</code></pre><p>See also: <a href="#ImplicitDomainQuadrature.lagrange_polynomial-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1},Int64}} where T"><code>lagrange_polynomial</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/lagrange_polynomials.jl#LL86-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.min_diam-Tuple{IntervalArithmetic.IntervalBox}" href="#ImplicitDomainQuadrature.min_diam-Tuple{IntervalArithmetic.IntervalBox}"><code>ImplicitDomainQuadrature.min_diam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">min_diam(box::IntervalBox)</code></pre><p>return the minimum diameter of <code>box</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/bounds.jl#LL28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.normalization-Union{Tuple{T}, Tuple{AbstractArray{T,1},Int64}} where T" href="#ImplicitDomainQuadrature.normalization-Union{Tuple{T}, Tuple{AbstractArray{T,1},Int64}} where T"><code>ImplicitDomainQuadrature.normalization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalization(roots::AbstractVector{T},skipindex::Int) where {T}</code></pre><p>return the denominator of the standard Lagrange polynomial formula.</p><p>Dividing <code>f = polynomial_from_roots(x,roots,skipindex)/normalization(roots,skipindex)</code> gives a normalized polynomial which evaluates to <code>1.0</code> on the <code>skipindex</code>th root i.e. <code>f(roots[skipindex] = 1.0</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ImplicitDomainQuadrature.normalization([-1,1],1)
-2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/lagrange_polynomials.jl#LL34-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.polynomial_from_roots-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1},Int64}} where T" href="#ImplicitDomainQuadrature.polynomial_from_roots-Union{Tuple{T}, Tuple{DynamicPolynomials.PolyVar,AbstractArray{T,1},Int64}} where T"><code>ImplicitDomainQuadrature.polynomial_from_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynomial_from_roots(x::DP.PolyVar,roots::AbstractVector{T},skipindex::Int) where {T}</code></pre><p>return a <code>DynamicPolynomial</code> with variable <code>x</code> with zeros at <code>roots</code> but skipping the <code>skipindex</code>th root.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; import DynamicPolynomials.@polyvar
julia&gt; @polyvar x
(x,)
julia&gt; ImplicitDomainQuadrature.polynomial_from_roots(x,[-1,1],1)
x - 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/lagrange_polynomials.jl#LL9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.quadrature_transformers-Tuple{Any,Any}" href="#ImplicitDomainQuadrature.quadrature_transformers-Tuple{Any,Any}"><code>ImplicitDomainQuadrature.quadrature_transformers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">quadrature_transformers(lo, hi)</code></pre><p>return <code>0.5(hi - lo), 0.5*(hi + lo)</code> which are the factors used to transform a quadrature rule from <code>(-1,1)</code> to <code>(lo,hi)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.roots_and_ends-Union{Tuple{T}, Tuple{Array{T,1} where T,T,T}} where T&lt;:Real" href="#ImplicitDomainQuadrature.roots_and_ends-Union{Tuple{T}, Tuple{Array{T,1} where T,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.roots_and_ends</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">roots_and_ends(F::Vector, x1::T, x2::T)</code></pre><p>return a sorted array containing <code>[x1, &lt;roots of each f in F&gt;, x2]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/dimension_reduction.jl#LL33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.run_search-NTuple{4,Any}" href="#ImplicitDomainQuadrature.run_search-NTuple{4,Any}"><code>ImplicitDomainQuadrature.run_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">run_search(f, interval, algorithm, tol, order)</code></pre><p>run a <code>BranchAndPrune</code> search until the sign of <code>f</code> in the given interval is determined</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/bounds.jl#LL104-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.signConditionsSatisfied-Tuple{Any,Any,Any}" href="#ImplicitDomainQuadrature.signConditionsSatisfied-Tuple{Any,Any,Any}"><code>ImplicitDomainQuadrature.signConditionsSatisfied</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">signConditionsSatisfied(funcs,xc,sign_conditions)</code></pre><p>return true if each <code>f</code> in <code>funcs</code> evaluated at <code>xc</code> has the sign specified in <code>sign_conditions</code>. Note: if <code>sign_conditions[i] == 0</code> then the function always returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/dimension_reduction.jl#LL92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.surface_quadrature-Union{Tuple{T}, Tuple{InterpolatingPolynomial,Int64,T,T,AbstractArray{T,1},T}} where T" href="#ImplicitDomainQuadrature.surface_quadrature-Union{Tuple{T}, Tuple{InterpolatingPolynomial,Int64,T,T,AbstractArray{T,1},T}} where T"><code>ImplicitDomainQuadrature.surface_quadrature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surface_quadrature(F::InterpolatingPolynomial, height_dir::Int, lo::T, hi::T, x0::AbstractVector{T}, w0::T) where {T}</code></pre><p>return a <code>point,weight</code> pair representing a quadrature point and weight that is obtained by projecting <code>x0</code> along <code>height_dir</code> onto the zero level set of <code>F</code> within the interval <code>(lo,hi)</code>. <code>weight</code> is scaled appropriately by the curvature of <code>F</code>     surface<em>quadrature(F::InterpolatingPolynomial, height</em>dir::Int, int::Interval{T}, x0::AbstractVector{T}, w0::T) where {T} convenience function when the interval within which to project <code>x0</code> is defined by an <code>Interval</code> type     surface<em>quadrature(F::InterpolatingPolynomial, height</em>dir::Int, lo::T, hi::T, x0::AbstractMatrix{T}, w0::AbstractVector{T}) where {T} project each column of <code>x0</code> onto the zero level set of <code>F</code>     surface<em>quadrature(F::InterpolatingPolynomial, height</em>dir::Int, int::Interval{T}, x0::AbstractMatrix{T}, w0::AbstractVector{T}) where {T}     quadrature(P::InterpolatingPolynomial{N,NF,B,T}, sign_condition::Int, surface::Bool, box::IntervalBox{2,T}, quad1d::ReferenceQuadratureRule{NQ,T}) where {B&lt;:TensorProductBasis{2}} where {N,NF,NQ,T} corresponds to Algorithm 3 of Robert Saye&#39;s 2015 SIAM paper</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/dimension_reduction.jl#LL179-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.tensorProduct-Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule,IntervalArithmetic.IntervalBox{2,T} where T}" href="#ImplicitDomainQuadrature.tensorProduct-Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule,IntervalArithmetic.IntervalBox{2,T} where T}"><code>ImplicitDomainQuadrature.tensorProduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tensorProduct(quad1d::ReferenceQuadratureRule, box::IntervalBox{2})</code></pre><p>returns a quadrature rule representing the &quot;tensor product&quot; or &quot;kroneker product&quot; of <code>quad1d</code> that is appropriately transformed into <code>box</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.tensorProductPoints-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}" href="#ImplicitDomainQuadrature.tensorProductPoints-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>ImplicitDomainQuadrature.tensorProductPoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tensorProductPoints(p1::Matrix, p2::Matrix)</code></pre><p>returns a matrix of points representing the &quot;tensor product&quot; (or kroneker product) of <code>p1</code> and <code>p2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL204-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.transform-Union{Tuple{T}, Tuple{N}, Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T},T,T}} where T where N" href="#ImplicitDomainQuadrature.transform-Union{Tuple{T}, Tuple{N}, Tuple{ImplicitDomainQuadrature.ReferenceQuadratureRule{N,T},T,T}} where T where N"><code>ImplicitDomainQuadrature.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform(quad::ReferenceQuadratureRule{N,T}, lo::T, hi::T) where {N,T}</code></pre><p>transform <code>quad</code> from the interval <code>[-1,1]</code> to the interval <code>[a,b]</code>     transform(quad::ReferenceQuadratureRule, int::Interval) transform <code>quad</code> from the interval <code>[-1,1]</code> to <code>int</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/quadrature_structs.jl#LL95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.unique_root_intervals-Union{Tuple{T}, Tuple{Any,T,T}} where T&lt;:Real" href="#ImplicitDomainQuadrature.unique_root_intervals-Union{Tuple{T}, Tuple{Any,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.unique_root_intervals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unique_root_intervals(f, x1::T, x2::T) where {T&lt;:Real}</code></pre><p>returns sub-intervals in <code>[x1,x2]</code> which contain unique roots of <code>f</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/dimension_reduction.jl#LL10-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.unique_roots-Union{Tuple{T}, Tuple{Any,T,T}} where T&lt;:Real" href="#ImplicitDomainQuadrature.unique_roots-Union{Tuple{T}, Tuple{Any,T,T}} where T&lt;:Real"><code>ImplicitDomainQuadrature.unique_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unique_roots(f, x1::T, x2::T) where {T&lt;:Real}</code></pre><p>returns the unique roots of <code>f</code> in the interval <code>(x1, x2)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/dimension_reduction.jl#LL20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImplicitDomainQuadrature.value_and_derivative-Union{Tuple{T}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis,T}} where T&lt;:Number" href="#ImplicitDomainQuadrature.value_and_derivative-Union{Tuple{T}, Tuple{ImplicitDomainQuadrature.LagrangePolynomialBasis,T}} where T&lt;:Number"><code>ImplicitDomainQuadrature.value_and_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">value_and_derivative(B::LagrangePolynomialBasis, x::Number)</code></pre><p>return <code>(v,d)</code> where <code>v</code> is a vector of the polynomial basis values and <code>d</code> is a vector of the derivative values of the polynomial basis at the point <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ArjunNarayanan/ImplicitDomainQuadrature/blob/288e0d4e1155478914a5383e52028e85c9020dcd/src/basis.jl#LL201-L205">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 19 February 2020 01:33">Wednesday 19 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
